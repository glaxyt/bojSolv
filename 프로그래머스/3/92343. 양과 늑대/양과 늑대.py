from collections import deque

def solution(info, edges):
    ## info = [0,0,1,1,1,0,1,0,1,0,1,1]	
    ## edges = [[0,1],[1,2],[1,4],[0,8],[8,7],[9,10],[9,11],[4,3],[6,5],[4,6],[8,9]]
    graph = [[] for _ in range(len(info))]
    
    ## 그래프 만들기
    for a, b in edges:
        graph[a].append(b)
        
    answer = [0]
    
    ## graph = [[1, 8], [2, 4], .....]
    def dfs(cx, s, w, que):        
        if info[cx] == 0:
            s += 1
            answer[0] = max(answer[0], s)
        else:
            w += 1
            
        if s <= w:
            return
            
        que.extend(graph[cx])
        
        for nx in que:
            dfs(nx, s, w, [i for i in que if i != nx])
    
    
    dfs(0, 0, 0, graph[0])
    return answer[0]


## 우선 양이 있는 곳을 위주로 찾아서 가야합니다.
## 자신 없다면 전역 탐색
## 이진트리가 기본, 여기서 
## 0 -> 양, 1 -> 늑대

## 그렇다면 어디로 가야하는가?
## 루트는 항상 0 즉 양이 존재한다.
## 각 간선에 대한 정보는 다음과 같이 주어진다.
## [[0,1],[1,2],[1,4],[0,8],[8,7],[9,10],[9,11],[4,3],[6,5],[4,6],[8,9]]	
## 이렇게 되면 0번하고 1번, 0번하고 8번이 이어져있다. 이는 단방향 노드가 아닌 양방향으로 구현해야 가능하다.
## BFS를 통해서 전역탐색을 한 뒤, 어디가 더 많은 값을 가져다 주는지 테스트 
## 간선 간에 가중치가 없기 때문 
## 큐 안에 모든 정보를 저장할 예정, 양과 늑대를 저장할 것입니다. 
## 이전에 탐색한 영역에서 막힐 경우, 다시 재탐색이 불가능하다는 것을 알게됨. 따로 Visited를 보유해야하나 생각이 듬, 
## 이전에 지나쳐간 영역도 다시 갈 수 있게해야함.
## 루트로 다시 돌아온다는 문장 때문에 DFS로 변경